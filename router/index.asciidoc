= http router

== http router 是什么

从功能上来讲，就是 URI -> handler 函数的映射。

[ditaa,file="url_to_handler.png"]
----
                                                 +------------------------------------------------------+
                                                 |func sayhello(wr http.ResponseWriter, r #http.Request)|
+------------------------------+                 |{                                                     |
|/superstar/jay/albums/#:id    |---------------->|    io.WriteString(wr, "fantasy")                     |
+------------------------------+                 |}                                                     |
|/superstar/cxk/skills         |--------+        +------------------------------------------------------+
+------------------------------+        |                                                                
                                        |                                                                
                                        |                                                                
                                        |        +------------------------------------------------------+
                                        |        |func sayhello(wr http.ResponseWriter, r #http.Request)|
                                        |        |{                                                     |
                                        +------->|    io.WriteString(wr, "sing dance rap basketball")   |
                                                 |}                                                     |
                                                 +------------------------------------------------------+
----

== http router 构造
=== 普通的 trie

image::trie.png[]

* 单个节点代表一个字母
* 如果需要对字符串进行匹配
* 只要从根节点开始依次匹配即可

普通的 trie 有什么缺点呢？

[quote,Wikipedia, 最长的英文单词]
____
在主要的英文字典中，最长的单词是pneumonoultramicroscopicsilicovolcanoconiosis，由45个字母组成，意思是一种肺部疾病（由于吸入超显微硅酸盐及石英尘所引起的）肺尘埃沉着病”，通称火山矽肺病。其中，pneumo-表示“肺”，ultra-表示“超”，microscopic意为“微观”，silico-表示“硅”，volcano指“火山”，coni-意思是“尘”，-osis为表示疾病的后缀。后来研究者认为这是一个大骗局。
____

* 树的深度和字符串长度正相关
* 占用较多的内存
* 字符串越长，匹配越慢(类似链表结构，在内存中存储不连续的数据)

=== radix tree

[quote,Wikipedia]
____
In computer science, a radix tree (also radix trie or compact prefix tree) is a data structure that represents a space-optimized trie (prefix tree) in which each node that is the only child is merged with its parent. The result is that the number of children of every internal node is at most the radix r of the radix tree, where r is a positive integer and a power x of 2, having x ≥ 1. Unlike regular tries, edges can be labeled with sequences of elements as well as single elements. This makes radix trees much more efficient for small sets (especially if the strings are long) and for sets of strings that share long prefixes.
____

在 http 路由的场景下 一棵 radix tree 是不够用的 为什么呢?

==== restful 风格路由


[ditaa,file="entries.png"]
----
                      +--------------------+                      
                      |   /user/#id/info   |                      
                      +--------------------+                      
                                 |                                
                                 |                                
                                 |                                
       +------------+------------+------------+------------+      
       |            |            |            |            |      
       |            |            |            |            |      
       v            v            v            v            v      
+------------+------------+------------+------------+------------+
|   DELETE   |    PUT     |   PATCH    |    POST    |    GET     |
+------------+------------+------------+------------+------------+
----

同一个 URI 会提供多个 HTTP 方法，以对“资源”进行创建、更新、删除、获取。如果我们只有一棵树，显然是没有办法支持的。

怎么解决这个问题呢？

=== 多棵 radix tree

GET 一棵，PUT 一棵，POST 一棵，以此类推：

[ditaa,file="radix_tree.png"]
----
      +-----+            +------+           +-------+    
      | PUT |            | POST |           | PATCH |    
      +-----+            +------+           +-------+    
         |                   |                  |        
         |                   |                  |        
         |                   |                  |        
         |                   |                  |        
         v                   v                  v        
  +------------+      +------------+     +------------+  
  | /bilibili  |      | /bilibili  |     | /bilibili  |  
  +------------+      +------------+     +------------+  
         |                   |                  |        
         |                   |                  |        
   +-----+---+          +----+---+          +---+----+   
   |         |          |        |          |        |   
   v         v          v        v          v        v   
+-----+   +-----+    +-----+  +-----+    +-----+  +-----+
| /22 |   | /33 |    | /33 |  | /44 |    | /55 |  | /44 |
+-----+   +-----+    +-----+  +-----+    +-----+  +-----+
----

== httprouter 中的一些概念

=== node

就是 httprouter 树中的节点。

=== nType

就是 node type，有 root、param、default 等几种枚举值。

=== path

到达节点时，所经过的字符串路径。

TODO，图

=== indices

当前节点的直接子节点的首字母枚举。

TODO，图

=== wildChild

如果一个节点的子节点中有 wildCard 节点，那么该节点的 wildChild 字段即为 true。

=== catchAll

TODO

以 `*` 结尾的路由，即为 catchAll

== httprouter 中 radix tree 的构造过程

=== 第一条路由

image::node_insert1.png[]

=== 第二条路由

image::node_insert2.png[]

=== 第三条路由

image::node_insert3.png[]

== 路由冲突

路由发生冲突，主要是 wildCard 节点、catchAll 节点和字符串节点的冲突，例如：

=== case 1

[source,c]
----
conflict:
GET /user/info/:name
GET /user/:id
----

为什么会冲突呢？因为 wildCard 和普通字符串节点是没有办法共存的。例如输入路由字符串为：`/user/info`，在 `/user/:id` 规则中，info 会被解释为 :id 的值。

[source,c]
----
no conflict:
GET /user/info/:name
POST /user/:id
----

两个路由的 HTTP Method(GET/POST) 不同，因此会在不同的 radix tree 上。

=== case 2

TODO

== 一些注意事项

== 正则路由与非正则路由

=== 功能对比

=== 性能对比

== 路由层的性能有意义么?

https://github.com/smallnest/go-web-framework-benchmark

image::benchmark_latency.png[]
